# [Gold I] 좋은 부분 문자열의 개수 - 13507 

[문제 링크](https://www.acmicpc.net/problem/13507) 

### 성능 요약

메모리: 530760 KB, 시간: 772 ms

### 분류

브루트포스 알고리즘, 자료 구조, 해싱, 해시를 사용한 집합과 맵, 누적 합, 문자열, 트리, 트라이

### 제출 일자

2025년 3월 28일 20:54:08

### 문제 설명

<p>알파벳 소문자로 이루어진 문자열 s가 주어진다. 알파벳 중에서 일부는 좋고, 나머지는 나쁘다.</p>

<p>문자열 s = s<sub>1</sub>s<sub>2</sub>...s<sub>|s|</sub>(|s|는 문자열 s의 길이)의 부분 문자열 s[l...r] (1 ≤ l ≤ r ≤ |s|)는 s<sub>l</sub>s<sub>l+1</sub>...s<sub>r</sub> 이다.</p>

<p>만약, s[l...r]을 이루고 있는 알파벳 s<sub>l</sub>, s<sub>l+1</sub>, ..., s<sub>r</sub> 중에서 나쁜 알파벳의 개수가 최대 k개라면, 그 부분 문자열을 좋다고 한다.</p>

<p>s의 서로 다른 좋은 부분 문자열의 개수를 찾는 프로그램을 작성하시오. s[x...y] ≠ s[p...q]인 경우에 두 부분 문자열 s[x...y]와 s[p...q]를 서로 다르다고 한다.</p>

### 입력 

 <p>첫째 줄에 알파벳 소문자로 이루어진 문자열 s가 주어진다. s의 길이는 1500을 넘지 않는다.</p>

<p>둘째 줄에는 26개의 0과 1로 이루어진 문자열이 주어진다. i번째 글자가 1인 경우에는 i번째 알파벳이 좋은 알파벳이라는 것, 0인 경우는 나쁜 알파벳이라는 것을 의미한다. 즉, 첫 번째 문자는 알파벳 'a'를 나타내며, 두 번째 문자는 'b'를 나타낸다.</p>

<p>셋째 줄에는 k (0 ≤ k ≤ |s|)가 주어진다.</p>

### 출력 

 <p>s의 서로 다른 좋은 부분 문자열의 개수를 출력한다.</p>

